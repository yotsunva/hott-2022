## recはrecursionよりも広い意味を持っているのか？
recursionが想像以上に広い意味を持っているかもしれない。
誤解を恐れずに言えば「構成子に関する適切なパターンマッチで関数が定義できる」ことを保証していて、ある意味で自由生成性を保証している。

## Inductive familyについて
Id x yをinductiveに定める際、各x, yに対して個別に定めているわけではなく、x, yを添え字として持つtype familyとして一括で定めている
（List AのAがparameterであるのに対し、Id x yのx, yはindexである。前者はAごとに個別に定められるが、後者はそうではない）。
inductive typeは型として構成子から自由生成されるのに対し、
inductive familyはtype familyとして構成子から自由生成される。
※ここで、自由生成という言葉は「適切な除去則（普遍性）を満たす」
あるいは
「構成子に関する適切なパターンマッチによって関数を定義できる」
という意味で使っている（自由生成性については後で詳しく述べる）。

## xとyが異なる場合はId x yの項をreflから直接は作り出せないのでは？
文字通り読むと構文側の話に見えるが、モデル側の話かもしれないので両方について述べる。

### 構文側の話
「Id tt ffのように、xとyが閉項で、簡約すると異なる項になる場合、Id x yの閉項をreflから直接は作り出せないのでは？」
という疑問になる気がする。
これは正しい。
この場合にId x yの閉項が作れたとすると、その閉項は当然簡約してもrefl aという形では書けない（書けるならxとyは簡約するとどちらもaになる）。
簡約しても構成子の組み合わせで書けない閉項が作れる原因としては、
「公理や悪い規則を認めた結果、正規化性やcanonicityが崩れた」というのが考えられる。
正規化性やcanonicity成り立つ状況においては
「inductive typeの閉項を簡約すると構成子（と場合によってはprimitive）の組み合わせで表せる」
ことを期待して良いと思う（場合によっては複雑な話になる）。
### モデル側の話
「モデルにおいて閉項x, yが異なる対象に対応する場合、型Id x yを持つ項pに対応するモデル内の対象があったなら、refl aという形の項と対応しないのでは？」
という疑問になる気がする。
これも（少なくとも良いモデルについては）正しい（しかもcanonicity云々に関わらず普通に起こりうる）。
ホモトピー論的なモデルにおいて、interval I（HITの一種）は[0,1]に対応する。
端点0,1は異なる対象で、型理論において与えられるp : Id 0 1に対応するのは0から1への道だが、
これはconstant loopではなく、refl xという形の項には対応しない。

工事中
