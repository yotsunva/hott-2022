## recはrecursionよりも広い意味を持っているのか？
recursionが想像以上に広い意味を持っているかもしれない。
誤解を恐れずに言えば「構成子に関する適切なパターンマッチで関数が定義できる」ことを保証していて、ある意味で自由生成性を保証している。

## Inductive familyについて
Id x yをinductiveに定める際、各x, yに対して個別に定めているわけではなく、x, yを添え字として持つtype familyとして一括で定めている
（List AのAがparameterであるのに対し、Id x yのx, yはindexである。前者はAごとに個別に定められるが、後者はそうではない）。
inductive typeは型として構成子から自由生成されるのに対し、
inductive familyはtype familyとして構成子から自由生成される。
※ここで、自由生成という言葉は「適切な除去則（普遍性）を満たす」
あるいは
「構成子に関する適切なパターンマッチによって関数を定義できる」
という意味で使っている（自由生成性については後で詳しく述べる）。

## xとyが異なる場合はId x yの項をreflから直接は作り出せないのでは？
文字通り読むと構文側の話に見えるが、モデル側の話かもしれないので両方について述べる。

### 構文側の話
「Id tt ffのように、xとyが閉項で、簡約すると異なる項になる場合、Id x yの閉項をreflから直接は作り出せないのでは？」
という疑問になる気がする。
これは正しい。
この場合にId x yの閉項が作れたとすると、その閉項は当然簡約してもrefl aという形では書けない（書けるならxとyは簡約するとどちらもaになる）。
簡約しても構成子の組み合わせで書けない閉項が作れる原因としては、
「公理や悪い規則を認めた結果、正規化性やcanonicityが崩れた」というのが考えられる。
正規化性やcanonicity成り立つ状況においては
「inductive typeの閉項を簡約すると構成子（と場合によってはprimitive）の組み合わせで表せる」
ことを期待して良いと思う（場合によっては複雑な話になる）。
### モデル側の話
「モデルにおいて閉項x, yが異なる対象に対応する場合、型Id x yを持つ項pに対応するモデル内の対象があったなら、refl aという形の項と対応しないのでは？」
という疑問になる気がする。
これも（少なくとも良いモデルについては）正しい（しかもcanonicity云々に関わらず普通に起こりうる）。
ホモトピー論的なモデルにおいて、interval I（HITの一種）は[0,1]に対応する。
端点0,1は異なる対象で、型理論において与えられるp : Id 0 1に対応するのは0から1への道だが、
これはconstant loopではなく、refl xという形の項には対応しない。

## 自由生成性って何？
「自由生成という言葉の解釈の多さ」が全ての元凶になっていると思われる。
「Idがreflによって自由生成される」は多くの解釈において正しい（Idの除去則がこれを保証する）。
以下、自由生成という言葉の解釈について述べる。

### 型理論内の命題としての解釈
- 除去則に対応する命題は当然示せる。
- Boolで言えば(x : Bool) → ((Id x tt) + (Id x ff))のような命題について（Boolの場合は示せる）：
  - (x : A) → (p : Id x x) → Id p (refl x)はMLTTにおいて証明も反証もできない。HoTTにおいて反証できる。
  - λx. (x, x, refl x) : A → Σ(x, y : A). Id x yが型の間のequivalenceになることは示せる。
  - (x, y : A) → (p : Id x y) → Id (x, y, p) (x, x, refl x)は示せる。

### 型理論の構文に関するメタな主張としての解釈
canonicity（閉項を簡約すると構成子の組み合わせで表せる）は公理のないMLTTでは成り立つ。HoTTでは成り立たない。

### 型理論のモデルに関する主張としての解釈
「個々のモデルにおいて、inductive type (family)に対応する対象が "対応する対象として" 構成子に対応する対象から自由生成される」は良いモデルにおいて成り立つはず（対応する対象が除去則という普遍性を満たすので）。
いくつかのモデルにおける例を挙げる。
- type family B→TypeをBで添え字付けられた集合族に対応させる（MLTTの）集合論的なモデルにおいては、Id_A に対応する対象は集合族 {S_a}_{a∈A} として refl_a∈S_a (a∈A) から自由生成される（refl_a を入れるだけで集合族になるので、自由生成しても新たな元は追加されない）。
- type family B→TypeをBを底空間とするfibrationと対応させるモデルにおいて、Id_Aに対応する対象（path space fibration A^I→A×A）はfibrationとして Δ : A→A×A から自由生成される（fibration では path の持ち上げ等ができるので、自由生成する際にそれを演算として使って良い）。
- type family B→Typeを∞-groupoid Bからuniverse U（対象は∞-groupoidで高次の射も自然に定める）への関手と対応させるモデルにおいて、Id_A に対応する対象は 関手 F : A→U として refl_a∈F(a) から自由生成される（関手は射を保つので、自由生成する際に送られた射を演算として使って良い）。
