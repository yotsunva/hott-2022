<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>index</title><link rel="stylesheet" href="Agda.css"></head><body><pre><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Option">--without-K</a> <a id="25" class="Option">--safe</a> <a id="32" class="Symbol">#-}</a>

<a id="37" class="Comment">-- 3.2. 宇宙</a>
<a id="48" class="Comment">-- 色々な流儀があるが、ここでは可算無限個（実質的には任意有限個）の宇宙によって階層づけを行える型理論について考える</a>
<a id="108" class="Comment">-- つまり Type0 : Type1, Type1 : Type2 ,... となっているとする</a>
<a id="159" class="Comment">-- Coq では宇宙のレベルは Coq 側が勝手に付けてくれる（矛盾なく付けられない場合はエラーを返す）</a>
<a id="213" class="Comment">-- Agda ではユーザーが宇宙のレベルを書く必要がある（単に Set と書くと、一番下の宇宙を指していることになる）</a>
<a id="274" class="Comment">-- 宇宙に関する面白い話題はいくつかあるが、ここでは触れない</a>

<a id="307" class="Comment">-- ちなみに、宇宙に関して U : U を認めると矛盾する</a>
<a id="338" class="Comment">-- 矛盾を導く議論は色々あるが、初期のものとしては Girard&#39;s paradox がある（後に Hurkens によって簡略化された）</a>
  <a id="411" class="Comment">-- Girard&#39;s paradox は System U のような inductive type の構成に関する規則がない体系でも機能する</a>
  <a id="485" class="Comment">-- 内容は集合論における Burali-Forti paradox と似ている</a>
  <a id="528" class="Comment">-- 集合論における Russell&#39;s paradox よりは少し複雑</a>
    <a id="569" class="Comment">-- Russell&#39;s paradox に似た議論を型理論で直接行うことは難しい（理由を考えると面白いかも）</a>
    <a id="629" class="Comment">-- inductive type を認めれば、間接的に Russell&#39;s paradox に似た議論を行える</a>


<a id="688" class="Comment">-- 3.3. 関数型</a>

<a id="701" class="Comment">-- ℓ で universe のレベルを表す</a>

<a id="726" class="Comment">-- 恒等関数</a>
<a id="id"></a><a id="734" href="index.html#734" class="Function">id</a> <a id="737" class="Symbol">:</a> <a id="739" class="Symbol">∀</a> <a id="741" class="Symbol">{</a><a id="742" href="index.html#742" class="Bound">ℓ</a><a id="743" class="Symbol">}</a> <a id="745" class="Symbol">{</a><a id="746" href="index.html#746" class="Bound">A</a> <a id="748" class="Symbol">:</a> <a id="750" class="PrimitiveType">Set</a> <a id="754" href="index.html#742" class="Bound">ℓ</a><a id="755" class="Symbol">}</a> <a id="757" class="Symbol">→</a> <a id="759" href="index.html#746" class="Bound">A</a> <a id="761" class="Symbol">→</a> <a id="763" href="index.html#746" class="Bound">A</a>
<a id="765" href="index.html#734" class="Function">id</a> <a id="768" href="index.html#768" class="Bound">x</a> <a id="770" class="Symbol">=</a> <a id="772" href="index.html#768" class="Bound">x</a>
<a id="774" class="Comment">-- 正規形は λ x → x</a>

<a id="791" class="Comment">-- 合成</a>
<a id="_∘_"></a><a id="797" href="index.html#797" class="Function Operator">_∘_</a> <a id="801" class="Symbol">:</a> <a id="803" class="Symbol">∀</a> <a id="805" class="Symbol">{</a><a id="806" href="index.html#806" class="Bound">ℓ</a><a id="807" class="Symbol">}</a> <a id="809" class="Symbol">{</a><a id="810" href="index.html#810" class="Bound">A</a> <a id="812" href="index.html#812" class="Bound">B</a> <a id="814" href="index.html#814" class="Bound">C</a> <a id="816" class="Symbol">:</a> <a id="818" class="PrimitiveType">Set</a> <a id="822" href="index.html#806" class="Bound">ℓ</a><a id="823" class="Symbol">}</a> <a id="825" class="Symbol">→</a> <a id="827" class="Symbol">(</a><a id="828" href="index.html#812" class="Bound">B</a> <a id="830" class="Symbol">→</a> <a id="832" href="index.html#814" class="Bound">C</a><a id="833" class="Symbol">)</a> <a id="835" class="Symbol">→</a> <a id="837" class="Symbol">(</a><a id="838" href="index.html#810" class="Bound">A</a> <a id="840" class="Symbol">→</a> <a id="842" href="index.html#812" class="Bound">B</a><a id="843" class="Symbol">)</a> <a id="845" class="Symbol">→</a> <a id="847" class="Symbol">(</a><a id="848" href="index.html#810" class="Bound">A</a> <a id="850" class="Symbol">→</a> <a id="852" href="index.html#814" class="Bound">C</a><a id="853" class="Symbol">)</a>
<a id="855" class="Symbol">(</a><a id="856" href="index.html#856" class="Bound">g</a> <a id="858" href="index.html#797" class="Function Operator">∘</a> <a id="860" href="index.html#860" class="Bound">f</a><a id="861" class="Symbol">)</a> <a id="863" href="index.html#863" class="Bound">x</a> <a id="865" class="Symbol">=</a> <a id="867" href="index.html#856" class="Bound">g</a> <a id="869" class="Symbol">(</a><a id="870" href="index.html#860" class="Bound">f</a> <a id="872" href="index.html#863" class="Bound">x</a><a id="873" class="Symbol">)</a>
<a id="875" class="Comment">-- 正規形は λ g f x → g (f x)</a>

<a id="902" class="Comment">-- id は関数型上の0項演算、_∘_ は関数型上の2項演算だと思うこともできる</a>
<a id="944" class="Comment">-- これらの演算に関する性質をいくつか示す</a>

<a id="968" class="Comment">-- identity type</a>
<a id="985" class="Keyword">data</a> <a id="Id"></a><a id="990" href="index.html#990" class="Datatype">Id</a> <a id="993" class="Symbol">{</a><a id="994" href="index.html#994" class="Bound">ℓ</a><a id="995" class="Symbol">}</a> <a id="997" class="Symbol">{</a><a id="998" href="index.html#998" class="Bound">A</a> <a id="1000" class="Symbol">:</a> <a id="1002" class="PrimitiveType">Set</a> <a id="1006" href="index.html#994" class="Bound">ℓ</a><a id="1007" class="Symbol">}</a> <a id="1009" class="Symbol">:</a> <a id="1011" href="index.html#998" class="Bound">A</a> <a id="1013" class="Symbol">→</a> <a id="1015" href="index.html#998" class="Bound">A</a> <a id="1017" class="Symbol">→</a> <a id="1019" class="PrimitiveType">Set</a> <a id="1023" href="index.html#994" class="Bound">ℓ</a> <a id="1025" class="Keyword">where</a>
  <a id="Id.refl"></a><a id="1033" href="index.html#1033" class="InductiveConstructor">refl</a> <a id="1038" class="Symbol">:</a> <a id="1040" class="Symbol">{</a><a id="1041" href="index.html#1041" class="Bound">x</a> <a id="1043" class="Symbol">:</a> <a id="1045" href="index.html#998" class="Bound">A</a><a id="1046" class="Symbol">}</a> <a id="1048" class="Symbol">→</a> <a id="1050" href="index.html#990" class="Datatype">Id</a> <a id="1053" href="index.html#1041" class="Bound">x</a> <a id="1055" href="index.html#1041" class="Bound">x</a>

<a id="id-lunit"></a><a id="1058" href="index.html#1058" class="Function">id-lunit</a> <a id="1067" class="Symbol">:</a> <a id="1069" class="Symbol">∀</a> <a id="1071" class="Symbol">{</a><a id="1072" href="index.html#1072" class="Bound">ℓ</a><a id="1073" class="Symbol">}</a> <a id="1075" class="Symbol">{</a><a id="1076" href="index.html#1076" class="Bound">A</a> <a id="1078" href="index.html#1078" class="Bound">B</a> <a id="1080" class="Symbol">:</a> <a id="1082" class="PrimitiveType">Set</a> <a id="1086" href="index.html#1072" class="Bound">ℓ</a><a id="1087" class="Symbol">}</a> <a id="1089" class="Symbol">{</a><a id="1090" href="index.html#1090" class="Bound">f</a> <a id="1092" class="Symbol">:</a> <a id="1094" href="index.html#1076" class="Bound">A</a> <a id="1096" class="Symbol">→</a> <a id="1098" href="index.html#1078" class="Bound">B</a><a id="1099" class="Symbol">}</a> <a id="1101" class="Symbol">→</a> <a id="1103" href="index.html#990" class="Datatype">Id</a> <a id="1106" href="index.html#1090" class="Bound">f</a> <a id="1108" class="Symbol">(</a><a id="1109" href="index.html#1090" class="Bound">f</a> <a id="1111" href="index.html#797" class="Function Operator">∘</a> <a id="1113" href="index.html#734" class="Function">id</a><a id="1115" class="Symbol">)</a>
<a id="1117" href="index.html#1058" class="Function">id-lunit</a> <a id="1126" class="Symbol">=</a> <a id="1128" href="index.html#1033" class="InductiveConstructor">refl</a>
<a id="1133" class="Comment">-- f ∘ id の正規形は λ x → f x で、f を η 展開するとこれに一致する</a>

<a id="id-runit"></a><a id="1181" href="index.html#1181" class="Function">id-runit</a> <a id="1190" class="Symbol">:</a> <a id="1192" class="Symbol">∀</a> <a id="1194" class="Symbol">{</a><a id="1195" href="index.html#1195" class="Bound">ℓ</a><a id="1196" class="Symbol">}</a> <a id="1198" class="Symbol">{</a><a id="1199" href="index.html#1199" class="Bound">A</a> <a id="1201" href="index.html#1201" class="Bound">B</a> <a id="1203" class="Symbol">:</a> <a id="1205" class="PrimitiveType">Set</a> <a id="1209" href="index.html#1195" class="Bound">ℓ</a><a id="1210" class="Symbol">}</a> <a id="1212" class="Symbol">{</a><a id="1213" href="index.html#1213" class="Bound">f</a> <a id="1215" class="Symbol">:</a> <a id="1217" href="index.html#1199" class="Bound">A</a> <a id="1219" class="Symbol">→</a> <a id="1221" href="index.html#1201" class="Bound">B</a><a id="1222" class="Symbol">}</a> <a id="1224" class="Symbol">→</a> <a id="1226" href="index.html#990" class="Datatype">Id</a> <a id="1229" href="index.html#1213" class="Bound">f</a> <a id="1231" class="Symbol">(</a><a id="1232" href="index.html#734" class="Function">id</a> <a id="1235" href="index.html#797" class="Function Operator">∘</a> <a id="1237" href="index.html#1213" class="Bound">f</a><a id="1238" class="Symbol">)</a>
<a id="1240" href="index.html#1181" class="Function">id-runit</a> <a id="1249" class="Symbol">=</a> <a id="1251" href="index.html#1033" class="InductiveConstructor">refl</a>

<a id="∘-assoc"></a><a id="1257" href="index.html#1257" class="Function">∘-assoc</a> <a id="1265" class="Symbol">:</a> <a id="1267" class="Symbol">∀</a> <a id="1269" class="Symbol">{</a><a id="1270" href="index.html#1270" class="Bound">ℓ</a><a id="1271" class="Symbol">}</a> <a id="1273" class="Symbol">{</a><a id="1274" href="index.html#1274" class="Bound">A</a> <a id="1276" href="index.html#1276" class="Bound">B</a> <a id="1278" href="index.html#1278" class="Bound">C</a> <a id="1280" href="index.html#1280" class="Bound">D</a> <a id="1282" class="Symbol">:</a> <a id="1284" class="PrimitiveType">Set</a> <a id="1288" href="index.html#1270" class="Bound">ℓ</a><a id="1289" class="Symbol">}</a> <a id="1291" class="Symbol">{</a><a id="1292" href="index.html#1292" class="Bound">f</a> <a id="1294" class="Symbol">:</a> <a id="1296" href="index.html#1274" class="Bound">A</a> <a id="1298" class="Symbol">→</a> <a id="1300" href="index.html#1276" class="Bound">B</a><a id="1301" class="Symbol">}</a> <a id="1303" class="Symbol">{</a><a id="1304" href="index.html#1304" class="Bound">g</a> <a id="1306" class="Symbol">:</a> <a id="1308" href="index.html#1276" class="Bound">B</a> <a id="1310" class="Symbol">→</a> <a id="1312" href="index.html#1278" class="Bound">C</a><a id="1313" class="Symbol">}</a> <a id="1315" class="Symbol">{</a><a id="1316" href="index.html#1316" class="Bound">h</a> <a id="1318" class="Symbol">:</a> <a id="1320" href="index.html#1278" class="Bound">C</a> <a id="1322" class="Symbol">→</a> <a id="1324" href="index.html#1280" class="Bound">D</a><a id="1325" class="Symbol">}</a> <a id="1327" class="Symbol">→</a> <a id="1329" href="index.html#990" class="Datatype">Id</a> <a id="1332" class="Symbol">((</a><a id="1334" href="index.html#1316" class="Bound">h</a> <a id="1336" href="index.html#797" class="Function Operator">∘</a> <a id="1338" href="index.html#1304" class="Bound">g</a><a id="1339" class="Symbol">)</a> <a id="1341" href="index.html#797" class="Function Operator">∘</a> <a id="1343" href="index.html#1292" class="Bound">f</a><a id="1344" class="Symbol">)</a> <a id="1346" class="Symbol">(</a><a id="1347" href="index.html#1316" class="Bound">h</a> <a id="1349" href="index.html#797" class="Function Operator">∘</a> <a id="1351" class="Symbol">(</a><a id="1352" href="index.html#1304" class="Bound">g</a> <a id="1354" href="index.html#797" class="Function Operator">∘</a> <a id="1356" href="index.html#1292" class="Bound">f</a><a id="1357" class="Symbol">))</a>
<a id="1360" href="index.html#1257" class="Function">∘-assoc</a> <a id="1368" class="Symbol">=</a> <a id="1370" href="index.html#1033" class="InductiveConstructor">refl</a>
<a id="1375" class="Comment">-- (h ∘ g) ∘ f, h ∘ (g ∘ f) の正規形はどちらも λ x → h (g (f x))</a>


<a id="1433" class="Comment">-- 4.1. inductive type</a>

<a id="1457" class="Comment">-- empty type</a>
<a id="1471" class="Keyword">data</a> <a id="⊥"></a><a id="1476" href="index.html#1476" class="Datatype">⊥</a> <a id="1478" class="Symbol">:</a> <a id="1480" class="PrimitiveType">Set</a> <a id="1484" class="Keyword">where</a>

<a id="1491" class="Comment">-- 否定</a>
<a id="¬"></a><a id="1497" href="index.html#1497" class="Function">¬</a> <a id="1499" class="Symbol">:</a> <a id="1501" class="Symbol">∀</a> <a id="1503" class="Symbol">{</a><a id="1504" href="index.html#1504" class="Bound">ℓ</a><a id="1505" class="Symbol">}</a> <a id="1507" class="Symbol">→</a> <a id="1509" class="PrimitiveType">Set</a> <a id="1513" href="index.html#1504" class="Bound">ℓ</a> <a id="1515" class="Symbol">→</a> <a id="1517" class="PrimitiveType">Set</a> <a id="1521" href="index.html#1504" class="Bound">ℓ</a>
<a id="1523" href="index.html#1497" class="Function">¬</a> <a id="1525" href="index.html#1525" class="Bound">A</a> <a id="1527" class="Symbol">=</a> <a id="1529" href="index.html#1525" class="Bound">A</a> <a id="1531" class="Symbol">→</a> <a id="1533" href="index.html#1476" class="Datatype">⊥</a>

<a id="1536" class="Comment">-- 自然数の型</a>
<a id="1545" class="Keyword">data</a> <a id="ℕ"></a><a id="1550" href="index.html#1550" class="Datatype">ℕ</a> <a id="1552" class="Symbol">:</a> <a id="1554" class="PrimitiveType">Set</a> <a id="1558" class="Keyword">where</a>
  <a id="ℕ.zero"></a><a id="1566" href="index.html#1566" class="InductiveConstructor">zero</a> <a id="1571" class="Symbol">:</a> <a id="1573" href="index.html#1550" class="Datatype">ℕ</a>
  <a id="ℕ.suc"></a><a id="1577" href="index.html#1577" class="InductiveConstructor">suc</a> <a id="1581" class="Symbol">:</a> <a id="1583" href="index.html#1550" class="Datatype">ℕ</a> <a id="1585" class="Symbol">→</a> <a id="1587" href="index.html#1550" class="Datatype">ℕ</a>

<a id="1590" class="Comment">-- Agda のパターンマッチは強いので、以下のようなこともパターンマッチで示せる</a>
<a id="1633" class="Comment">-- 普通に除去則を使っても示せるが、少し工夫が要る</a>
  <a id="1662" class="Comment">-- HoTT book 2.13 にある encode-decode method が一つのやり方</a>

<a id="suc-inj"></a><a id="1714" href="index.html#1714" class="Function">suc-inj</a> <a id="1722" class="Symbol">:</a> <a id="1724" class="Symbol">{</a><a id="1725" href="index.html#1725" class="Bound">m</a> <a id="1727" href="index.html#1727" class="Bound">n</a> <a id="1729" class="Symbol">:</a> <a id="1731" href="index.html#1550" class="Datatype">ℕ</a><a id="1732" class="Symbol">}</a> <a id="1734" class="Symbol">→</a> <a id="1736" href="index.html#990" class="Datatype">Id</a> <a id="1739" class="Symbol">(</a><a id="1740" href="index.html#1577" class="InductiveConstructor">suc</a> <a id="1744" href="index.html#1725" class="Bound">m</a><a id="1745" class="Symbol">)</a> <a id="1747" class="Symbol">(</a><a id="1748" href="index.html#1577" class="InductiveConstructor">suc</a> <a id="1752" href="index.html#1727" class="Bound">n</a><a id="1753" class="Symbol">)</a> <a id="1755" class="Symbol">→</a> <a id="1757" href="index.html#990" class="Datatype">Id</a> <a id="1760" href="index.html#1725" class="Bound">m</a> <a id="1762" href="index.html#1727" class="Bound">n</a>
<a id="1764" href="index.html#1714" class="Function">suc-inj</a> <a id="1772" href="index.html#1033" class="InductiveConstructor">refl</a> <a id="1777" class="Symbol">=</a> <a id="1779" href="index.html#1033" class="InductiveConstructor">refl</a>

<a id="suc-ne-zero"></a><a id="1785" href="index.html#1785" class="Function">suc-ne-zero</a> <a id="1797" class="Symbol">:</a> <a id="1799" class="Symbol">{</a><a id="1800" href="index.html#1800" class="Bound">n</a> <a id="1802" class="Symbol">:</a> <a id="1804" href="index.html#1550" class="Datatype">ℕ</a><a id="1805" class="Symbol">}</a> <a id="1807" class="Symbol">→</a> <a id="1809" href="index.html#1497" class="Function">¬</a> <a id="1811" class="Symbol">(</a><a id="1812" href="index.html#990" class="Datatype">Id</a> <a id="1815" class="Symbol">(</a><a id="1816" href="index.html#1577" class="InductiveConstructor">suc</a> <a id="1820" href="index.html#1800" class="Bound">n</a><a id="1821" class="Symbol">)</a> <a id="1823" href="index.html#1566" class="InductiveConstructor">zero</a><a id="1827" class="Symbol">)</a>
<a id="1829" href="index.html#1785" class="Function">suc-ne-zero</a> <a id="1841" class="Symbol">()</a>
<a id="1844" class="Comment">-- Id (suc n) zero の項に関するパターンマッチ</a>
<a id="1877" class="Comment">-- パターンが無いので、空のパターンマッチを行っている</a>

<a id="1907" class="Comment">-- 前者関数</a>
<a id="pred"></a><a id="1915" href="index.html#1915" class="Function">pred</a> <a id="1920" class="Symbol">:</a> <a id="1922" href="index.html#1550" class="Datatype">ℕ</a> <a id="1924" class="Symbol">→</a> <a id="1926" href="index.html#1550" class="Datatype">ℕ</a>
<a id="1928" href="index.html#1915" class="Function">pred</a> <a id="1933" href="index.html#1566" class="InductiveConstructor">zero</a> <a id="1938" class="Symbol">=</a> <a id="1940" href="index.html#1566" class="InductiveConstructor">zero</a>
<a id="1945" href="index.html#1915" class="Function">pred</a> <a id="1950" class="Symbol">(</a><a id="1951" href="index.html#1577" class="InductiveConstructor">suc</a> <a id="1955" href="index.html#1955" class="Bound">n</a><a id="1956" class="Symbol">)</a> <a id="1958" class="Symbol">=</a> <a id="1960" href="index.html#1955" class="Bound">n</a>

<a id="pred-suc"></a><a id="1963" href="index.html#1963" class="Function">pred-suc</a> <a id="1972" class="Symbol">:</a> <a id="1974" href="index.html#990" class="Datatype">Id</a> <a id="1977" href="index.html#734" class="Function">id</a> <a id="1980" class="Symbol">(</a><a id="1981" href="index.html#1915" class="Function">pred</a> <a id="1986" href="index.html#797" class="Function Operator">∘</a> <a id="1988" href="index.html#1577" class="InductiveConstructor">suc</a><a id="1991" class="Symbol">)</a>
<a id="1993" href="index.html#1963" class="Function">pred-suc</a> <a id="2002" class="Symbol">=</a> <a id="2004" href="index.html#1033" class="InductiveConstructor">refl</a>


<a id="2011" class="Comment">-- 4.2. fibration (type family), total space</a>

<a id="2057" class="Keyword">data</a> <a id="Σ"></a><a id="2062" href="index.html#2062" class="Datatype">Σ</a> <a id="2064" class="Symbol">{</a><a id="2065" href="index.html#2065" class="Bound">ℓ</a><a id="2066" class="Symbol">}</a> <a id="2068" class="Symbol">(</a><a id="2069" href="index.html#2069" class="Bound">B</a> <a id="2071" class="Symbol">:</a> <a id="2073" class="PrimitiveType">Set</a> <a id="2077" href="index.html#2065" class="Bound">ℓ</a><a id="2078" class="Symbol">)</a> <a id="2080" class="Symbol">(</a><a id="2081" href="index.html#2081" class="Bound">E</a> <a id="2083" class="Symbol">:</a> <a id="2085" href="index.html#2069" class="Bound">B</a> <a id="2087" class="Symbol">→</a> <a id="2089" class="PrimitiveType">Set</a> <a id="2093" href="index.html#2065" class="Bound">ℓ</a><a id="2094" class="Symbol">)</a> <a id="2096" class="Symbol">:</a> <a id="2098" class="PrimitiveType">Set</a> <a id="2102" href="index.html#2065" class="Bound">ℓ</a> <a id="2104" class="Keyword">where</a>
  <a id="Σ._,_"></a><a id="2112" href="index.html#2112" class="InductiveConstructor Operator">_,_</a> <a id="2116" class="Symbol">:</a> <a id="2118" class="Symbol">(</a><a id="2119" href="index.html#2119" class="Bound">x</a> <a id="2121" class="Symbol">:</a> <a id="2123" href="index.html#2069" class="Bound">B</a><a id="2124" class="Symbol">)</a> <a id="2126" class="Symbol">→</a> <a id="2128" href="index.html#2081" class="Bound">E</a> <a id="2130" href="index.html#2119" class="Bound">x</a> <a id="2132" class="Symbol">→</a> <a id="2134" href="index.html#2062" class="Datatype">Σ</a> <a id="2136" href="index.html#2069" class="Bound">B</a> <a id="2138" href="index.html#2081" class="Bound">E</a>
<a id="2140" class="Keyword">open</a> <a id="2145" href="index.html#2062" class="Module">Σ</a>
<a id="2147" class="Comment">-- 引数 B は implicit にしても良いが、ここでは明示することにする。</a>

<a id="2190" class="Keyword">syntax</a> <a id="2197" href="index.html#2062" class="Datatype">Σ</a> B <a id="2201" class="Symbol">(λ</a> x <a id="2206" class="Symbol">→</a> E-x<a id="2211" class="Symbol">)</a> <a id="2213" class="Symbol">=</a> Σ x ꞉ B , E-x
<a id="2229" class="Comment">-- 大して変わらないが、informal な型理論において使われる記法に近い記法を導入した</a>

<a id="2277" class="Comment">-- Π-type に関する記法も導入しておく</a>
<a id="Π"></a><a id="2301" href="index.html#2301" class="Function">Π</a> <a id="2303" class="Symbol">:</a> <a id="2305" class="Symbol">∀</a> <a id="2307" class="Symbol">{</a><a id="2308" href="index.html#2308" class="Bound">ℓ</a><a id="2309" class="Symbol">}</a> <a id="2311" class="Symbol">(</a><a id="2312" href="index.html#2312" class="Bound">A</a> <a id="2314" class="Symbol">:</a> <a id="2316" class="PrimitiveType">Set</a> <a id="2320" href="index.html#2308" class="Bound">ℓ</a><a id="2321" class="Symbol">)</a> <a id="2323" class="Symbol">(</a><a id="2324" href="index.html#2324" class="Bound">B</a> <a id="2326" class="Symbol">:</a> <a id="2328" href="index.html#2312" class="Bound">A</a> <a id="2330" class="Symbol">→</a> <a id="2332" class="PrimitiveType">Set</a> <a id="2336" href="index.html#2308" class="Bound">ℓ</a><a id="2337" class="Symbol">)</a> <a id="2339" class="Symbol">→</a> <a id="2341" class="PrimitiveType">Set</a> <a id="2345" href="index.html#2308" class="Bound">ℓ</a>
<a id="2347" href="index.html#2301" class="Function">Π</a> <a id="2349" href="index.html#2349" class="Bound">A</a> <a id="2351" href="index.html#2351" class="Bound">B</a> <a id="2353" class="Symbol">=</a> <a id="2355" class="Symbol">(</a><a id="2356" href="index.html#2356" class="Bound">x</a> <a id="2358" class="Symbol">:</a> <a id="2360" href="index.html#2349" class="Bound">A</a><a id="2361" class="Symbol">)</a> <a id="2363" class="Symbol">→</a> <a id="2365" href="index.html#2351" class="Bound">B</a> <a id="2367" href="index.html#2356" class="Bound">x</a>

<a id="2370" class="Keyword">syntax</a> <a id="2377" href="index.html#2301" class="Function">Π</a> B <a id="2381" class="Symbol">(λ</a> x <a id="2386" class="Symbol">→</a> E-x<a id="2391" class="Symbol">)</a> <a id="2393" class="Symbol">=</a> Π x ꞉ B , E-x

<a id="2410" class="Comment">-- Σ-type を使った product type の定義</a>
<a id="prod"></a><a id="2442" href="index.html#2442" class="Function">prod</a> <a id="2447" class="Symbol">:</a> <a id="2449" class="Symbol">∀</a> <a id="2451" class="Symbol">{</a><a id="2452" href="index.html#2452" class="Bound">ℓ</a><a id="2453" class="Symbol">}</a> <a id="2455" class="Symbol">(</a><a id="2456" href="index.html#2456" class="Bound">A</a> <a id="2458" href="index.html#2458" class="Bound">B</a> <a id="2460" class="Symbol">:</a> <a id="2462" class="PrimitiveType">Set</a> <a id="2466" href="index.html#2452" class="Bound">ℓ</a><a id="2467" class="Symbol">)</a> <a id="2469" class="Symbol">→</a> <a id="2471" class="PrimitiveType">Set</a> <a id="2475" href="index.html#2452" class="Bound">ℓ</a>
<a id="2477" href="index.html#2442" class="Function">prod</a> <a id="2482" href="index.html#2482" class="Bound">A</a> <a id="2484" href="index.html#2484" class="Bound">B</a> <a id="2486" class="Symbol">=</a> <a id="2488" href="index.html#2062" class="Datatype">Σ</a> <a id="2490" href="index.html#2490" class="Bound">x</a> <a id="2492" href="index.html#2062" class="Datatype">꞉</a> <a id="2494" href="index.html#2482" class="Bound">A</a> <a id="2496" href="index.html#2062" class="Datatype">,</a> <a id="2498" href="index.html#2484" class="Bound">B</a>

<a id="2501" class="Comment">-- 直接的な product type の定義</a>
<a id="2526" class="Keyword">data</a> <a id="_×_"></a><a id="2531" href="index.html#2531" class="Datatype Operator">_×_</a> <a id="2535" class="Symbol">{</a><a id="2536" href="index.html#2536" class="Bound">ℓ</a><a id="2537" class="Symbol">}</a> <a id="2539" class="Symbol">(</a><a id="2540" href="index.html#2540" class="Bound">A</a> <a id="2542" href="index.html#2542" class="Bound">B</a> <a id="2544" class="Symbol">:</a> <a id="2546" class="PrimitiveType">Set</a> <a id="2550" href="index.html#2536" class="Bound">ℓ</a><a id="2551" class="Symbol">)</a> <a id="2553" class="Symbol">:</a> <a id="2555" class="PrimitiveType">Set</a> <a id="2559" href="index.html#2536" class="Bound">ℓ</a> <a id="2561" class="Keyword">where</a>
  <a id="_×_._,_"></a><a id="2569" href="index.html#2569" class="InductiveConstructor Operator">_,_</a> <a id="2573" class="Symbol">:</a> <a id="2575" href="index.html#2540" class="Bound">A</a> <a id="2577" class="Symbol">→</a> <a id="2579" href="index.html#2542" class="Bound">B</a> <a id="2581" class="Symbol">→</a> <a id="2583" href="index.html#2540" class="Bound">A</a> <a id="2585" href="index.html#2531" class="Datatype Operator">×</a> <a id="2587" href="index.html#2542" class="Bound">B</a>

<a id="2590" class="Comment">-- Σ-type に関わる関数</a>
<a id="pr1"></a><a id="2607" href="index.html#2607" class="Function">pr1</a> <a id="2611" class="Symbol">:</a> <a id="2613" class="Symbol">∀</a> <a id="2615" class="Symbol">{</a><a id="2616" href="index.html#2616" class="Bound">ℓ</a><a id="2617" class="Symbol">}</a> <a id="2619" class="Symbol">{</a><a id="2620" href="index.html#2620" class="Bound">B</a> <a id="2622" class="Symbol">:</a> <a id="2624" class="PrimitiveType">Set</a> <a id="2628" href="index.html#2616" class="Bound">ℓ</a><a id="2629" class="Symbol">}</a> <a id="2631" class="Symbol">{</a><a id="2632" href="index.html#2632" class="Bound">E</a> <a id="2634" class="Symbol">:</a> <a id="2636" href="index.html#2620" class="Bound">B</a> <a id="2638" class="Symbol">→</a> <a id="2640" class="PrimitiveType">Set</a> <a id="2644" href="index.html#2616" class="Bound">ℓ</a><a id="2645" class="Symbol">}</a> <a id="2647" class="Symbol">→</a> <a id="2649" class="Symbol">(</a><a id="2650" href="index.html#2062" class="Datatype">Σ</a> <a id="2652" href="index.html#2652" class="Bound">x</a> <a id="2654" href="index.html#2062" class="Datatype">꞉</a> <a id="2656" href="index.html#2620" class="Bound">B</a> <a id="2658" href="index.html#2062" class="Datatype">,</a> <a id="2660" href="index.html#2632" class="Bound">E</a> <a id="2662" href="index.html#2652" class="Bound">x</a><a id="2663" class="Symbol">)</a> <a id="2665" class="Symbol">→</a> <a id="2667" href="index.html#2620" class="Bound">B</a>
<a id="2669" href="index.html#2607" class="Function">pr1</a> <a id="2673" class="Symbol">(</a><a id="2674" href="index.html#2674" class="Bound">x</a> <a id="2676" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="2678" href="index.html#2678" class="Bound">y</a><a id="2679" class="Symbol">)</a> <a id="2681" class="Symbol">=</a> <a id="2683" href="index.html#2674" class="Bound">x</a>

<a id="pr2"></a><a id="2686" href="index.html#2686" class="Function">pr2</a> <a id="2690" class="Symbol">:</a> <a id="2692" class="Symbol">∀</a> <a id="2694" class="Symbol">{</a><a id="2695" href="index.html#2695" class="Bound">ℓ</a><a id="2696" class="Symbol">}</a> <a id="2698" class="Symbol">{</a><a id="2699" href="index.html#2699" class="Bound">B</a> <a id="2701" class="Symbol">:</a> <a id="2703" class="PrimitiveType">Set</a> <a id="2707" href="index.html#2695" class="Bound">ℓ</a><a id="2708" class="Symbol">}</a> <a id="2710" class="Symbol">{</a><a id="2711" href="index.html#2711" class="Bound">E</a> <a id="2713" class="Symbol">:</a> <a id="2715" href="index.html#2699" class="Bound">B</a> <a id="2717" class="Symbol">→</a> <a id="2719" class="PrimitiveType">Set</a> <a id="2723" href="index.html#2695" class="Bound">ℓ</a><a id="2724" class="Symbol">}</a> <a id="2726" class="Symbol">→</a> <a id="2728" class="Symbol">(</a><a id="2729" href="index.html#2729" class="Bound">p</a> <a id="2731" class="Symbol">:</a> <a id="2733" href="index.html#2062" class="Datatype">Σ</a> <a id="2735" href="index.html#2735" class="Bound">x</a> <a id="2737" href="index.html#2062" class="Datatype">꞉</a> <a id="2739" href="index.html#2699" class="Bound">B</a> <a id="2741" href="index.html#2062" class="Datatype">,</a> <a id="2743" href="index.html#2711" class="Bound">E</a> <a id="2745" href="index.html#2735" class="Bound">x</a><a id="2746" class="Symbol">)</a> <a id="2748" class="Symbol">→</a> <a id="2750" href="index.html#2711" class="Bound">E</a> <a id="2752" class="Symbol">(</a><a id="2753" href="index.html#2607" class="Function">pr1</a> <a id="2757" href="index.html#2729" class="Bound">p</a><a id="2758" class="Symbol">)</a>
<a id="2760" href="index.html#2686" class="Function">pr2</a> <a id="2764" class="Symbol">(</a><a id="2765" href="index.html#2765" class="Bound">x</a> <a id="2767" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="2769" href="index.html#2769" class="Bound">y</a><a id="2770" class="Symbol">)</a> <a id="2772" class="Symbol">=</a> <a id="2774" href="index.html#2769" class="Bound">y</a>

<a id="2777" class="Comment">-- （直観主義）述語論理</a>

<a id="∀¬2¬∃"></a><a id="2792" href="index.html#2792" class="Function">∀¬2¬∃</a> <a id="2798" class="Symbol">:</a> <a id="2800" class="Symbol">∀</a> <a id="2802" class="Symbol">{</a><a id="2803" href="index.html#2803" class="Bound">ℓ</a><a id="2804" class="Symbol">}</a> <a id="2806" class="Symbol">{</a><a id="2807" href="index.html#2807" class="Bound">A</a> <a id="2809" class="Symbol">:</a> <a id="2811" class="PrimitiveType">Set</a> <a id="2815" href="index.html#2803" class="Bound">ℓ</a><a id="2816" class="Symbol">}</a> <a id="2818" class="Symbol">{</a><a id="2819" href="index.html#2819" class="Bound">P</a> <a id="2821" class="Symbol">:</a> <a id="2823" href="index.html#2807" class="Bound">A</a> <a id="2825" class="Symbol">→</a> <a id="2827" class="PrimitiveType">Set</a> <a id="2831" href="index.html#2803" class="Bound">ℓ</a><a id="2832" class="Symbol">}</a> <a id="2834" class="Symbol">→</a> <a id="2836" class="Symbol">(</a><a id="2837" href="index.html#2301" class="Function">Π</a> <a id="2839" href="index.html#2839" class="Bound">x</a> <a id="2841" href="index.html#2301" class="Function">꞉</a> <a id="2843" href="index.html#2807" class="Bound">A</a> <a id="2845" href="index.html#2301" class="Function">,</a> <a id="2847" href="index.html#1497" class="Function">¬</a> <a id="2849" class="Symbol">(</a><a id="2850" href="index.html#2819" class="Bound">P</a> <a id="2852" href="index.html#2839" class="Bound">x</a><a id="2853" class="Symbol">))</a> <a id="2856" class="Symbol">→</a> <a id="2858" href="index.html#1497" class="Function">¬</a> <a id="2860" class="Symbol">(</a><a id="2861" href="index.html#2062" class="Datatype">Σ</a> <a id="2863" href="index.html#2863" class="Bound">x</a> <a id="2865" href="index.html#2062" class="Datatype">꞉</a> <a id="2867" href="index.html#2807" class="Bound">A</a> <a id="2869" href="index.html#2062" class="Datatype">,</a> <a id="2871" href="index.html#2819" class="Bound">P</a> <a id="2873" href="index.html#2863" class="Bound">x</a><a id="2874" class="Symbol">)</a>
<a id="2876" href="index.html#2792" class="Function">∀¬2¬∃</a> <a id="2882" href="index.html#2882" class="Bound">anp</a> <a id="2886" class="Symbol">(</a><a id="2887" href="index.html#2887" class="Bound">x</a> <a id="2889" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="2891" href="index.html#2891" class="Bound">y</a><a id="2892" class="Symbol">)</a> <a id="2894" class="Symbol">=</a> <a id="2896" href="index.html#2882" class="Bound">anp</a> <a id="2900" href="index.html#2887" class="Bound">x</a> <a id="2902" href="index.html#2891" class="Bound">y</a>
<a id="2904" class="Comment">-- anp : (Π x ꞉ A , ¬ (P x)) と (x , y) : (Σ x ꞉ A , P x) から矛盾を導いている</a>

<a id="¬∃2∀¬"></a><a id="2973" href="index.html#2973" class="Function">¬∃2∀¬</a> <a id="2979" class="Symbol">:</a> <a id="2981" class="Symbol">∀</a> <a id="2983" class="Symbol">{</a><a id="2984" href="index.html#2984" class="Bound">ℓ</a><a id="2985" class="Symbol">}</a> <a id="2987" class="Symbol">{</a><a id="2988" href="index.html#2988" class="Bound">A</a> <a id="2990" class="Symbol">:</a> <a id="2992" class="PrimitiveType">Set</a> <a id="2996" href="index.html#2984" class="Bound">ℓ</a><a id="2997" class="Symbol">}</a> <a id="2999" class="Symbol">{</a><a id="3000" href="index.html#3000" class="Bound">P</a> <a id="3002" class="Symbol">:</a> <a id="3004" href="index.html#2988" class="Bound">A</a> <a id="3006" class="Symbol">→</a> <a id="3008" class="PrimitiveType">Set</a> <a id="3012" href="index.html#2984" class="Bound">ℓ</a><a id="3013" class="Symbol">}</a> <a id="3015" class="Symbol">→</a> <a id="3017" href="index.html#1497" class="Function">¬</a> <a id="3019" class="Symbol">(</a><a id="3020" href="index.html#2062" class="Datatype">Σ</a> <a id="3022" href="index.html#3022" class="Bound">x</a> <a id="3024" href="index.html#2062" class="Datatype">꞉</a> <a id="3026" href="index.html#2988" class="Bound">A</a> <a id="3028" href="index.html#2062" class="Datatype">,</a> <a id="3030" href="index.html#3000" class="Bound">P</a> <a id="3032" href="index.html#3022" class="Bound">x</a><a id="3033" class="Symbol">)</a> <a id="3035" class="Symbol">→</a> <a id="3037" class="Symbol">(</a><a id="3038" href="index.html#2301" class="Function">Π</a> <a id="3040" href="index.html#3040" class="Bound">x</a> <a id="3042" href="index.html#2301" class="Function">꞉</a> <a id="3044" href="index.html#2988" class="Bound">A</a> <a id="3046" href="index.html#2301" class="Function">,</a> <a id="3048" href="index.html#1497" class="Function">¬</a> <a id="3050" class="Symbol">(</a><a id="3051" href="index.html#3000" class="Bound">P</a> <a id="3053" href="index.html#3040" class="Bound">x</a><a id="3054" class="Symbol">))</a>
<a id="3057" href="index.html#2973" class="Function">¬∃2∀¬</a> <a id="3063" href="index.html#3063" class="Bound">nep</a> <a id="3067" href="index.html#3067" class="Bound">x</a> <a id="3069" href="index.html#3069" class="Bound">px</a> <a id="3072" class="Symbol">=</a> <a id="3074" href="index.html#3063" class="Bound">nep</a> <a id="3078" class="Symbol">(</a><a id="3079" href="index.html#3067" class="Bound">x</a> <a id="3081" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="3083" href="index.html#3069" class="Bound">px</a><a id="3085" class="Symbol">)</a>
<a id="3087" class="Comment">-- nep : ¬ (Σ x ꞉ A , P x) と x ꞉ A と px : P x から矛盾を導いている</a>

<a id="∃¬2¬∀"></a><a id="3145" href="index.html#3145" class="Function">∃¬2¬∀</a> <a id="3151" class="Symbol">:</a> <a id="3153" class="Symbol">∀</a> <a id="3155" class="Symbol">{</a><a id="3156" href="index.html#3156" class="Bound">ℓ</a><a id="3157" class="Symbol">}</a> <a id="3159" class="Symbol">{</a><a id="3160" href="index.html#3160" class="Bound">A</a> <a id="3162" class="Symbol">:</a> <a id="3164" class="PrimitiveType">Set</a> <a id="3168" href="index.html#3156" class="Bound">ℓ</a><a id="3169" class="Symbol">}</a> <a id="3171" class="Symbol">{</a><a id="3172" href="index.html#3172" class="Bound">P</a> <a id="3174" class="Symbol">:</a> <a id="3176" href="index.html#3160" class="Bound">A</a> <a id="3178" class="Symbol">→</a> <a id="3180" class="PrimitiveType">Set</a> <a id="3184" href="index.html#3156" class="Bound">ℓ</a><a id="3185" class="Symbol">}</a> <a id="3187" class="Symbol">→</a> <a id="3189" class="Symbol">(</a><a id="3190" href="index.html#2062" class="Datatype">Σ</a> <a id="3192" href="index.html#3192" class="Bound">x</a> <a id="3194" href="index.html#2062" class="Datatype">꞉</a> <a id="3196" href="index.html#3160" class="Bound">A</a> <a id="3198" href="index.html#2062" class="Datatype">,</a> <a id="3200" href="index.html#1497" class="Function">¬</a> <a id="3202" class="Symbol">(</a><a id="3203" href="index.html#3172" class="Bound">P</a> <a id="3205" href="index.html#3192" class="Bound">x</a><a id="3206" class="Symbol">))</a> <a id="3209" class="Symbol">→</a> <a id="3211" href="index.html#1497" class="Function">¬</a> <a id="3213" class="Symbol">(</a><a id="3214" href="index.html#2301" class="Function">Π</a> <a id="3216" href="index.html#3216" class="Bound">x</a> <a id="3218" href="index.html#2301" class="Function">꞉</a> <a id="3220" href="index.html#3160" class="Bound">A</a> <a id="3222" href="index.html#2301" class="Function">,</a> <a id="3224" href="index.html#3172" class="Bound">P</a> <a id="3226" href="index.html#3216" class="Bound">x</a><a id="3227" class="Symbol">)</a>
<a id="3229" href="index.html#3145" class="Function">∃¬2¬∀</a> <a id="3235" class="Symbol">(</a><a id="3236" href="index.html#3236" class="Bound">x</a> <a id="3238" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="3240" href="index.html#3240" class="Bound">npx</a><a id="3243" class="Symbol">)</a> <a id="3245" href="index.html#3245" class="Bound">ap</a> <a id="3248" class="Symbol">=</a> <a id="3250" href="index.html#3240" class="Bound">npx</a> <a id="3254" class="Symbol">(</a><a id="3255" href="index.html#3245" class="Bound">ap</a> <a id="3258" href="index.html#3236" class="Bound">x</a><a id="3259" class="Symbol">)</a>
<a id="3261" class="Comment">-- (x , npx) : (Σ x ꞉ A , ¬ (P x)) と ap : (Π x ꞉ A , P x) から矛盾を導いている</a>

<a id="3331" class="Comment">-- ¬ (Π x ꞉ A , P x) → (Σ x ꞉ A , ¬ (P x)) は一般には示せない（排中律等を公理として与えれば示せる）</a>


<a id="3405" class="Comment">-- 構成的な choice（余談）</a>

<a id="3425" class="Comment">-- 一階述語論理上のZFC集合論において、選択公理 (AC) は公理として仮定されている</a>
<a id="3471" class="Comment">-- AC を仮定すると、一階述語論理で直観主義的なものを採用したとしても排中律 (LEM) と同等のことが言える (Diaconescu&#39;s theorem)</a>
  <a id="3554" class="Comment">-- 命題 P を持ってくると、P ∨ ¬ P が示せるということ</a>
  <a id="3590" class="Comment">-- 可算選択公理 (CC) や従属選択公理 (DC) から LEM と同等のことを言うことはできない</a>
    <a id="3646" class="Comment">-- 構成主義であっても、流儀によっては CC, DC を仮定する場合がある</a>

<a id="3686" class="Comment">-- 型理論の（計算の観点から見て）良い性質を保つためには、公理なしで（良い規則のみで）議論を行うべき</a>
  <a id="3740" class="Comment">-- 当然 LEM, AC を仮定すると良い性質 (canonicity) が壊れる</a>
<a id="3783" class="Comment">-- しかし、次の主張は規則のみから示すことができる</a>

<a id="choice"></a><a id="3811" href="index.html#3811" class="Function">choice</a> <a id="3818" class="Symbol">:</a> <a id="3820" class="Symbol">∀</a> <a id="3822" class="Symbol">{</a><a id="3823" href="index.html#3823" class="Bound">ℓ</a><a id="3824" class="Symbol">}</a> <a id="3826" class="Symbol">{</a><a id="3827" href="index.html#3827" class="Bound">Λ</a> <a id="3829" class="Symbol">:</a> <a id="3831" class="PrimitiveType">Set</a> <a id="3835" href="index.html#3823" class="Bound">ℓ</a><a id="3836" class="Symbol">}</a> <a id="3838" class="Symbol">{</a><a id="3839" href="index.html#3839" class="Bound">A</a> <a id="3841" class="Symbol">:</a> <a id="3843" href="index.html#3827" class="Bound">Λ</a> <a id="3845" class="Symbol">→</a> <a id="3847" class="PrimitiveType">Set</a> <a id="3851" href="index.html#3823" class="Bound">ℓ</a><a id="3852" class="Symbol">}</a> <a id="3854" class="Symbol">{</a><a id="3855" href="index.html#3855" class="Bound">P</a> <a id="3857" class="Symbol">:</a> <a id="3859" class="Symbol">(</a><a id="3860" href="index.html#3860" class="Bound">x</a> <a id="3862" class="Symbol">:</a> <a id="3864" href="index.html#3827" class="Bound">Λ</a><a id="3865" class="Symbol">)</a> <a id="3867" class="Symbol">→</a> <a id="3869" href="index.html#3839" class="Bound">A</a> <a id="3871" href="index.html#3860" class="Bound">x</a> <a id="3873" class="Symbol">→</a> <a id="3875" class="PrimitiveType">Set</a> <a id="3879" href="index.html#3823" class="Bound">ℓ</a><a id="3880" class="Symbol">}</a> <a id="3882" class="Symbol">→</a>
  <a id="3886" class="Symbol">(</a><a id="3887" href="index.html#2301" class="Function">Π</a> <a id="3889" href="index.html#3889" class="Bound">x</a> <a id="3891" href="index.html#2301" class="Function">꞉</a> <a id="3893" href="index.html#3827" class="Bound">Λ</a> <a id="3895" href="index.html#2301" class="Function">,</a> <a id="3897" href="index.html#2062" class="Datatype">Σ</a> <a id="3899" href="index.html#3899" class="Bound">a</a> <a id="3901" href="index.html#2062" class="Datatype">꞉</a> <a id="3903" href="index.html#3839" class="Bound">A</a> <a id="3905" href="index.html#3889" class="Bound">x</a> <a id="3907" href="index.html#2062" class="Datatype">,</a> <a id="3909" href="index.html#3855" class="Bound">P</a> <a id="3911" href="index.html#3889" class="Bound">x</a> <a id="3913" href="index.html#3899" class="Bound">a</a><a id="3914" class="Symbol">)</a> <a id="3916" class="Symbol">→</a> <a id="3918" class="Symbol">(</a><a id="3919" href="index.html#2062" class="Datatype">Σ</a> <a id="3921" href="index.html#3921" class="Bound">f</a> <a id="3923" href="index.html#2062" class="Datatype">꞉</a> <a id="3925" class="Symbol">((</a><a id="3927" href="index.html#3927" class="Bound">x</a> <a id="3929" class="Symbol">:</a> <a id="3931" href="index.html#3827" class="Bound">Λ</a><a id="3932" class="Symbol">)</a> <a id="3934" class="Symbol">→</a> <a id="3936" href="index.html#3839" class="Bound">A</a> <a id="3938" href="index.html#3927" class="Bound">x</a><a id="3939" class="Symbol">)</a> <a id="3941" href="index.html#2062" class="Datatype">,</a> <a id="3943" href="index.html#2301" class="Function">Π</a> <a id="3945" href="index.html#3945" class="Bound">x</a> <a id="3947" href="index.html#2301" class="Function">꞉</a> <a id="3949" href="index.html#3827" class="Bound">Λ</a> <a id="3951" href="index.html#2301" class="Function">,</a> <a id="3953" href="index.html#3855" class="Bound">P</a> <a id="3955" href="index.html#3945" class="Bound">x</a> <a id="3957" class="Symbol">(</a><a id="3958" href="index.html#3921" class="Bound">f</a> <a id="3960" href="index.html#3945" class="Bound">x</a><a id="3961" class="Symbol">))</a>
<a id="3964" href="index.html#3811" class="Function">choice</a> <a id="3971" href="index.html#3971" class="Bound">axeapxa</a> <a id="3979" class="Symbol">=</a> <a id="3981" class="Symbol">(λ</a> <a id="3984" href="index.html#3984" class="Bound">x</a> <a id="3986" class="Symbol">→</a> <a id="3988" href="index.html#2607" class="Function">pr1</a> <a id="3992" class="Symbol">(</a><a id="3993" href="index.html#3971" class="Bound">axeapxa</a> <a id="4001" href="index.html#3984" class="Bound">x</a><a id="4002" class="Symbol">))</a> <a id="4005" href="index.html#2112" class="InductiveConstructor Operator">,</a> <a id="4007" class="Symbol">(λ</a> <a id="4010" href="index.html#4010" class="Bound">x</a> <a id="4012" class="Symbol">→</a> <a id="4014" href="index.html#2686" class="Function">pr2</a> <a id="4018" class="Symbol">(</a><a id="4019" href="index.html#3971" class="Bound">axeapxa</a> <a id="4027" href="index.html#4010" class="Bound">x</a><a id="4028" class="Symbol">))</a>
<a id="4031" class="Comment">-- Λ で添え字づけられた集合族 {A_x}_{x∈Λ} があるとき、</a>
<a id="4068" class="Comment">-- 任意の x∈Λ に対して「命題 P x a が成り立つような a∈A_λ が &quot;存在する&quot;」なら、</a>
<a id="4121" class="Comment">-- 「任意の x∈Λ に対して命題 P x (f x) が成り立つ」ような、選択関数 f ꞉ ((x : Λ) → A x) が &quot;存在する&quot;</a>

<a id="4195" class="Comment">-- Π, Σ が ∀, ∃ と対応していると思うなら、これは AC と同値な主張に対応する</a>
  <a id="4244" class="Comment">-- 厳密に言えば、関数型の項と写像も対応させている</a>
  <a id="4273" class="Comment">-- 集合論において写像はグラフ（ある種の集合）としてエンコードされているので、実はこれは少し非自明な対応のさせ方</a>
<a id="4331" class="Comment">-- しかし、この choice は規則のみから導けて、この choice から LEM が導かれることはない</a>

<a id="4388" class="Comment">-- 対応が崩れているように思われる原因は「Σ が ∃ と対応している」と思う部分にある</a>
<a id="4433" class="Comment">-- Σ は集合論における ∃ よりも強い意味を持っている</a>
  <a id="4465" class="Comment">-- 感覚的には、∃ が「性質 P を満たす対象が存在する」という情報しか持っていないのに対し、</a>
  <a id="4516" class="Comment">-- Σ は「…という対象が、性質 P を満たす」という情報を持っている</a>

<a id="4554" class="Comment">-- 型理論において ∃ に対応すると思えるものはあるのだろうか</a>
  <a id="4589" class="Comment">-- MLTT には無い（無理やりエンコードできるかもしれないけれど）</a>
  <a id="4627" class="Comment">-- pCIC（Coq, Lean のベース）にはある</a>
    <a id="4659" class="Comment">-- Prop という宇宙において Σ と同様に inductive に定まる命題が ∃ と対応すると思える</a>
  <a id="4716" class="Comment">-- HoTT, cubical type theory (CTT) にはある</a>
    <a id="4760" class="Comment">-- Σ の propositional truncation（higher inductive type の一種）が ∃ と対応すると思える</a>
  <a id="4834" class="Comment">-- pCIC の ∃ と HoTT の ∃ には微妙な違いがある</a>
    <a id="4872" class="Comment">-- pCIC の ∃ は ∃ に加えて一意性が言えたとしても、一般にそこから Σ を導くことはできない</a>
    <a id="4929" class="Comment">-- HoTT の ∃ ではできる</a></pre></body></html>